/**
 MIT License

Copyright (c) 2024 Marco Zeuli <marco@spaghetti.dev>;

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/**
 * Custom path assistant.
 * Standard path component doesn't support closed stages.
 * This component wants to mimic the Opportunity Sales Path where you can have
 * up to two closed statuses.
 *
 * Used only on RecordPages, this component is fully aware of it's context.
 */
import { LightningElement, api, wire } from 'lwc';
import {
    getObjectInfo,
    getPicklistValuesByRecordType
} from 'lightning/uiObjectInfoApi';
import { updateRecord, getRecord } from 'lightning/uiRecordApi';
import {
    ScenarioState,
    ScenarioLayout,
    MarkAsCompleteScenario,
    MarkAsCurrentScenario,
    SelectClosedScenario,
    ChangeClosedScenario,
    Step
} from './utils';

// value to assign to the last step when user has to select a proper closed step
const OPEN_MODAL_TO_SELECT_CLOSED_STEP = 'pathAssistant_selectAClosedStepValue';

export default class PathAssistant extends LightningElement {
    // current object api name
    @api objectApiName;

    // current record's id
    @api recordId;

    // picklist field's API name used to render the path assistant
    @api picklistField;

    // closed OK step value. When selected will render a green progress bar
    @api closedOk;

    // closed KO step value. When selected will render a red progress bar
    @api closedKo;

    // label to give the last step
    @api lastStepLabel;

    // show/hide the update button
    @api hideUpdateButton;

    // show/hide a loading spinner
    spinner = false;

    // show/hide the modal to select a closed step
    openModal = false;

    // current object metadata info
    objectInfo;

    // current record
    record;

    // error message, when set will render the error panel
    errorMsg;

    // available picklist values for current record (based on record type)
    possibleSteps;

    // step selected by the user
    selectedStepValue;

    // current record's record type id
    _recordTypeId;

    // action that can be performed by the user
    _currentScenario;

    // user selected closed step
    _selectedClosedStepValue;

    // array of possible user interaction scenarios
    _scenarios = [];

    // all hardcoded string, these can be replaced with custom label for translation
    labels = {
        selectClosed: 'Select Closed {0}',
        markAsComplete: 'Mark {0} as Complete',
        markAsCurrent: 'Mark as Current {0}',
        changeClosed: 'Change Closed {0}',
        genericErrorMessage:
            'An unexpected error occurred. Please contact your System Administrator.'
    };

    // this is the token that gets replaced with field label
    _token = '{0}';

    /**
     * Creates possible user interaction scenarios
     */
    constructor() {
        super();

        // note: all the hard coded strings passed to ScenarioLayout can be replaced with Custom Labels

        this._scenarios.push(
            new MarkAsCompleteScenario(
                new ScenarioLayout(
                    this.labels.selectClosed,
                    this.labels.markAsComplete,
                    this._token
                )
            )
        );

        this._scenarios.push(
            new MarkAsCurrentScenario(
                new ScenarioLayout('', this.labels.markAsCurrent, this._token)
            )
        );

        this._scenarios.push(
            new SelectClosedScenario(
                new ScenarioLayout(
                    this.labels.selectClosed,
                    this.labels.selectClosed,
                    this._token
                )
            )
        );

        this._scenarios.push(
            new ChangeClosedScenario(
                new ScenarioLayout(
                    this.labels.selectClosed,
                    this.labels.changeClosed,
                    this._token
                )
            )
        );
    }

    /* ========== WIRED METHODS ========== */

    @wire(getRecord, {
        recordId: '$recordId',
        layoutTypes: 'Full',
        modes: 'View'
    })
    wiredRecord({ error, data }) {
        if (error) {
            this.errorMsg = error.body.message;
        }

        if (data) {
            // set the record
            this.record = data;

            // set the current record type
            this._recordTypeId = data.recordTypeId;
        }
    }

    @wire(getObjectInfo, { objectApiName: '$objectApiName' })
    wiredObject({ error, data }) {
        if (error) {
            this.errorMsg = error.body.message;
        }

        if (data) {
            this.objectInfo = data;
        }
    }

    // load picklist values available for current record type
    @wire(getPicklistValuesByRecordType, {
        objectApiName: '$objectApiName',
        recordTypeId: '$_recordTypeId'
    })
    wiredPicklistValues({ error, data }) {
        if (!this._recordTypeId) {
            // invalid call
            return;
        }

        if (error) {
            this.errorMsg = error.body.message;
        }

        if (data) {
            if (data.picklistFieldValues[this.picklistField]) {
                // stores possible steps
                this.possibleSteps = data.picklistFieldValues[
                    this.picklistField
                ].values.map((elem, idx) => {
                    return new Step(elem.value, elem.label, idx);
                });

                // checks that required values are included
                this._validateSteps();
            } else {
                this.errorMsg = `Impossible to load ${
                    this.picklistField
                } values for record type ${this._recordTypeId}`;
            }
        }
    }

    /* ========== PRIVATE METHODS ========== */

    /**
     * Based on current component state set the current scenario
     */
    _setCurrentScenario() {
        const state = new ScenarioState(
            this.isClosed,
            this.selectedStepValue,
            this.currentStep.value,
            OPEN_MODAL_TO_SELECT_CLOSED_STEP
        );

        for (let idx in this._scenarios) {
            if (this._scenarios[idx].appliesToState(state)) {
                this._currentScenario = this._scenarios[idx];
                break;
            }
        }
    }

    /**
     * Validate picklist values available for current record type.
     * ClosedOk and ClosedKo values should be available together at least with another
     * value.
     */
    _validateSteps() {
        let isClosedOkAvailable = false;
        let isClosedKoAvailable = false;

        this.possibleSteps.forEach((step) => {
            isClosedKoAvailable |= step.equals(this.closedKo);
            isClosedOkAvailable |= step.equals(this.closedOk);
        });

        if (!isClosedOkAvailable) {
            this.errorMsg = `${
                this.closedOk
            } value is not available for record type ${this._recordTypeId}`;
        }

        if (!isClosedKoAvailable) {
            this.errorMsg = `${
                this.closedKo
            } value is not available for record type ${this._recordTypeId}`;
        }

        // checks steps contains at least three items (starting step plus the two closed ones)
        if (this.possibleSteps.length < 3) {
            // note: should I make this configurable?
            this.errorMsg = `Not enough picklist values are available for record type ${
                this._recordTypeId
            }.`;
        }
    }

    /**
     * Given a step returns the css class to apply in the rendered html element
     * @param {Object} step Step instance
     */
    _getStepElementCssClass(step) {
        let classText = 'slds-path__item';

        if (step.equals(this.closedOk)) {
            classText += ' slds-is-won';
        }

        if (step.equals(this.closedKo)) {
            classText += ' slds-is-lost';
        }

        if (step.equals(this.selectedStepValue)) {
            classText += ' slds-is-active';
        }

        if (step.equals(this.currentStep)) {
            classText += ' slds-is-current';

            if (!this.selectedStepValue) {
                // if user didn't select any step this is also the active one
                classText += ' slds-is-active';
            }
        } else if (step.isBefore(this.currentStep) && !this.isClosedKo) {
            classText += ' slds-is-complete';
        } else {
            // not yet completed or closedKo
            classText += ' slds-is-incomplete';
        }

        return classText;
    }

    /**
     * Reset the component state
     */
    _resetComponentState() {
        this.record = undefined;
        this.selectedStepValue = undefined;
        this._selectedClosedStepValue = undefined;
        this._currentScenario = undefined;
    }

    /**
     * Update current record with the specified step.
     * @param {String} stepValue Step value to set on current record
     */
    _updateRecord(stepValue) {
        // format the record for update call
        let toUpdate = {
            fields: {
                Id: this.recordId
            }
        };

        // set new field value
        toUpdate.fields[this.picklistField] = stepValue;

        // starts spinner
        this.spinner = true;

        updateRecord(toUpdate)
            .then(() => {
                // close spinner
                this.spinner = false;
            })
            .catch((error) => {
                this.errorMsg = error.body.message;
                this.spinner = false;
            });

        // reset component state
        this._resetComponentState();
    }

    /* ========== GETTER METHODS ========== */

    // returns current step of path assistant
    get currentStep() {
        for (let idx in this.possibleSteps) {
            if (
                this.possibleSteps[idx].equals(
                    this.record.fields[this.picklistField].value
                )
            ) {
                return this.possibleSteps[idx];
            }
        }
        // empty step
        return new Step();
    }

    // returns next step
    get nextStep() {
        return this.possibleSteps[this.currentStep.index + 1];
    }

    // get progress bar steps
    get steps() {
        let closedOkElem;
        let closedKoElem;

        // makes a copy of picklistValues. This is because during rendering phase we cannot alter the status of a tracked variable
        // const possibleSteps = JSON.parse(JSON.stringify(this.possibleSteps));

        let res = this.possibleSteps
            .filter((step) => {
                // filters out closed steps
                if (step.equals(this.closedOk)) {
                    closedOkElem = step;
                    return false;
                }

                if (step.equals(this.closedKo)) {
                    closedKoElem = step;
                    return false;
                }

                return true;
            })
            .map((step) => {
                // adds the classText property used to render correctly the element
                step.setClassText(this._getStepElementCssClass(step));
                return step;
            });

        let lastStep;

        if (this.isClosedOk) {
            lastStep = closedOkElem;
        } else if (this.isClosedKo) {
            lastStep = closedKoElem;
        } else {
            // record didn't reach a closed step
            // create a fake one that will allow users to pick either the closedOk or closedKo
            lastStep = new Step(
                OPEN_MODAL_TO_SELECT_CLOSED_STEP,
                this.lastStepLabel,
                Infinity
            );
        }

        lastStep.setClassText(this._getStepElementCssClass(lastStep));

        res.push(lastStep);

        return res;
    }

    // returns only closed steps
    get closedSteps() {
        return this.possibleSteps.filter((step) => {
            return step.equals(this.closedKo) || step.equals(this.closedOk);
        });
    }

    // return action button text label
    get updateButtonText() {
        return this._currentScenario
            ? this._currentScenario.layout.getUpdateButtonText(
                  this.picklistFieldLabel
              )
            : '';
    }

    // returns the header for the modal
    get modalHeader() {
        return this._currentScenario
            ? this._currentScenario.layout.getModalHeader(
                  this.picklistFieldLabel
              )
            : '';
    }

    // returns the label for the select input field inside the modal
    get selectLabel() {
        return this.picklistFieldLabel;
    }

    // returns the label of the picklist field used to render the path
    get picklistFieldLabel() {
        return this.objectInfo.fields[this.picklistField].label;
    }

    // true if current record reached a closed step
    get isClosed() {
        return this.isClosedKo || this.isClosedOk;
    }

    // true if current record was closed OK
    get isClosedOk() {
        return this.currentStep.equals(this.closedOk);
    }

    // true if current record was closed KO
    get isClosedKo() {
        return this.currentStep.equals(this.closedKo);
    }

    // true when all required data is loaded
    get isLoaded() {
        const res = this.record && this.objectInfo && this.possibleSteps;
        if (res && !this._currentScenario) {
            // when fully loaded initialize the action
            this._setCurrentScenario();
        }
        return res;
    }

    // true if picklist field is empty and user didn't select any value yet
    get isUpdateButtonDisabled() {
        return !this.currentStep.hasValue() && !this.selectedStepValue;
    }

    // true if either spinner = true or component is not fully loaded
    get hasToShowSpinner() {
        return this.spinner || !this.isLoaded;
    }

    get genericErrorMessage() {
        return this.labels.genericErrorMessage;
    }

    get displayUpdateButton() {
        return !this.hideUpdateButton;
    }

    /* ========== EVENT HANDLER METHODS ========== */

    /**
     * Called when user press either the Cancel button or the Close icon
     * in the modal.
     */
    closeModal() {
        this.openModal = false;
    }

    /**
     * Called when user selects a value for the closed step
     * @param {Event} event Change Event
     */
    setClosedStep(event) {
        this._selectedClosedStepValue = event.target.value;
    }

    /**
     * Called when user clicks on a step
     * @param {Event} event Click event
     */
    handleStepSelected(event) {
        this.selectedStepValue = event.currentTarget.getAttribute('data-value');
        this._setCurrentScenario();
    }

    /**
     * Called when user press the action button
     */
    handleUpdateButtonClick() {
        switch (this._currentScenario.constructor) {
            case MarkAsCompleteScenario:
                if (
                    this.nextStep.equals(this.closedKo) ||
                    this.nextStep.equals(this.closedOk)
                ) {
                    // in case next step is a closed one open the modal
                    this.openModal = true;
                } else {
                    // otherwise update the record directly
                    this._updateRecord(this.nextStep.value);
                }
                break;
            case MarkAsCurrentScenario:
                this._updateRecord(this.selectedStepValue);
                break;
            case SelectClosedScenario:
            case ChangeClosedScenario:
                this.openModal = true;
                break;
            default:
                break;
        }
    }

    /**
     * Called when user press Save button inside the modal
     */
    handleSaveButtonClick() {
        if (!this._selectedClosedStepValue) {
            return;
        }

        this._updateRecord(this._selectedClosedStepValue);
        this.openModal = false;
    }
}
